---
title: "Case Studies"
output:
  html_document:
    df_print: paged
---
```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(tidyverse)
library(lubridate)
library(sp)
library(sf)
library(raster)
library(rgeos)
library(rgdal)
library(viridis)
library(gridExtra)
library(rasterVis)
require(spatialEco)
library(plotly)
library(classInt)
library(ggmap)
```


```{r, echo=FALSE, warning=FALSE, message=FALSE}
# Load hex.sent
load("plots/hex.sent") # Twitter / Instagram hex level data
load("plots/twitter.pa.sent") # Twitter planning area level data
load("plots/insta.pa.sent") # Instagram planning area level data
load("plots/richpoor.sent") # Rich / poor data
```

```{r}
# tweets.sf <- mutate(tweets.sf, sent=pos-neg)
# ggplot(tweets.sf, aes(sent)) + geom_histogram() + ggtitle("Sentiment of Tweets, Kurtosis = 2.728617") + scale_x_continuous(limits=c(0,1.0))
```


```{r}
# insta.sf <- mutate(insta.sf, sent=pos-neg)
# ggplot(insta.sf, aes(sent)) + geom_histogram() + ggtitle("Sentiment of Instagram Posts, Kurtosis = 3.14983") + scale_x_continuous(limits=c(0,1.0))
```

**I. Sentiments on Twitter vs Instagram**

```{r, echo=FALSE, warning=FALSE, message=FALSE}
class_int <- classIntervals(twitter.pa.sent$norm, n = 4, style = "jenks")
rounded <- round(class_int$brks,3)
rounded[1] <- 0 

p <- ggplot() +
  geom_sf(data = twitter.pa.sent, aes(fill = cut(norm, class_int$brks), geometry = geometry, text = paste0(Name, "\n", "Sentiment: ", norm)), lwd = 0) + 
  theme_void() +
  coord_sf() +
  scale_fill_viridis(
    name="Normalized Sentiment",
    discrete = T,
    labels = c(rounded),
    guide=guide_legend(
      keyheight = unit(2, units = "mm"),
      keywidth=unit(18, units = "mm"),
      label.position = "bottom",
      title.position = 'top',
      nrow=1)) +
  labs(
    title = "Twitter Sentiments in Different Planning Zones",
    subtitle = "Normalized Sentiment score = (Positive - Negative)/Total Count",
    caption = "Data: Ate Poorthuis | Creation: Dragon Minions"
  ) +
  theme(
    text = element_text(color = "#22211d"),
    plot.background = element_rect(fill = "#ffffff", color = NA),
    panel.background = element_rect(fill = "#ffffff", color = NA),
    legend.background = element_rect(fill = "#ffffff", color = NA),
    plot.title = element_text(size= 18, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.4, l = 0, unit = "cm")),
    legend.position = c(0.81, 0.09),
    panel.grid.major = element_line(colour = 'transparent'),
    panel.grid.minor = element_line(colour = 'transparent')
  )

p
# ggplotly(p, tooltip = "text") %>%
#  highlight(
#    "plotly_hover",
#    opacityDim = 1
#  ) %>%
#   layout(legend = list(
#     orientation = 'h',
#     x = 0.1,
#     y = 0.1,
#     title = "Normalized Sentiment"))
```

From this map, we can see that people are the happiest around Sentosa, Marina Bay and Sungei Boloh Wetland reserve from the tweets. This makes sense as they are tourist attractions and are more likely visited by people for recreation. People tend to post tweets of enjoyment in their trips.

We can also tell that industrial islands in the south of Singapore are the least happy places. This could be the fact that people visiting the islands are likely there for mundane/tough industrial work, and tend to tweet about negative moods.

We can also see that the central of Singapore is slightly happier than the outskirts of the country. This may be due to the fact that the central of Singapore is bustling with more recreational activities and night-life. Tourists also tend to mainly explore the central regions of Singapore. This can result in more positive posts towards the centre of Singapore.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
class_int <- classIntervals(insta.pa.sent$norm, n = 4, style = "jenks")
rounded <- round(class_int$brks,3)
rounded[1] <- 0

p <- ggplot() +
  geom_sf(data = insta.pa.sent, aes(fill = cut(norm, class_int$brks), geometry = geometry, text = paste0(Name, "\n", "Sentiment: ", norm)), lwd = 0) + 
  theme_void() +
  coord_sf() +
  scale_fill_viridis(
    name="Normalized Sentiment",
    discrete = T,
    labels = rounded,
    guide=guide_legend(
      keyheight = unit(2, units = "mm"),
      keywidth=unit(18, units = "mm"),
      label.position = "bottom",
      title.position = 'top',
      nrow=1)) +
  labs(
    title = "Instagram Sentiment in Different Planning Zones",
    subtitle = "Normalized Sentiment score = (Positive - Negative)/Total Count",
    caption = "Data: Ate Poorthuis | Creation: Dragon Minions"
  ) +
  theme(
    text = element_text(color = "#22211d"),
    plot.background = element_rect(fill = "#ffffff", color = NA),
    panel.background = element_rect(fill = "#ffffff", color = NA),
    legend.background = element_rect(fill = "#ffffff", color = NA),
    plot.title = element_text(size= 18, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.4, l = 2, unit = "cm")),
    legend.position = c(0.81, 0.09),
    panel.grid.major = element_line(colour = 'transparent'),
    panel.grid.minor = element_line(colour = 'transparent')
  )

p
```

There are no posts in Tekong Island as posts about any military activity or facilities are prohibited.

We can see from this map that the East and Central are generally happier than the West of Singapore. This is apparent in regions like Tuas, the industrial islands and Lim Chu Kang. This can be due to the fact that they contain big parts of industrial factories, farmlands, cemetaries and forests. This can result in more negative posts.

The happiest areas are Punggol, Pasir Ris, Tanglin, Marina Bay and Ang Mo Kio, Changi Bay. This can be a result of higher recreational activities in these areas. Pasir Ris and Punggol have many parks, Tanglin has shopping centre and Botanical Gardens, Marina Bay is a tourist attraction and Ang Mo Kio has night-life and food places.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
class_int <- classIntervals(hex.sent$t.norm, n = 5, style = "jenks")
rounded <- round(class_int$brks,3)

p <- ggplot() +
  geom_sf(data = hex.sent, aes(fill=cut(t.norm, class_int$brks), geometry=geometry, text=paste0("Sentiment: ", t.norm)), lwd=0) + 
  theme_void() +
  coord_sf() +
  scale_fill_viridis(
    name="Normalized Sentiment",
    discrete=T,
    labels = rounded,
    guide=guide_legend(
      keyheight = unit(2, units = "mm"),
      keywidth=unit(12, units = "mm"),
      label.position = "bottom",
      title.position = 'top',
      nrow=1)) +
  labs(
    title = "Twitter Sentiment in Singapore",
    subtitle = "Normalized Sentiment score = (Positive - Negative)/Total Count",
    caption = "Data: Ate Poorthuis | Creation: Dragon Minions"
  ) +
  theme(
    text = element_text(color = "#22211d"), 
    plot.background = element_rect(fill = "#ffffff", color = NA), 
    panel.background = element_rect(fill = "#ffffff", color = NA), 
    legend.background = element_rect(fill = "#ffffff", color = NA),
    plot.title = element_text(size= 18, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.4, l = 2, unit = "cm")),
    legend.position = c(0.82, 0.09),
    panel.grid.major = element_line(colour = 'transparent'), 
    panel.grid.minor = element_line(colour = 'transparent')
  )

p
```

There are likely no posts within South of the Upper Seletar Reservoir as it is mainly vegetation.

From this map, we can see that Tekong, Lim Chu Kang Road, Tuas, the industrial islands and Tanah Merah Coast Road are the least happy areas. We know from the previous map that there are actually twitter posts in Tekong. Tweets in Tekong could be unhappy as the National Service Forces or National Service Men dread serving in the military. For Tanah Merah Coast Road, Tuas and industrial islands, people could be unhappy during their working hours. Lim Chu Kang Road has many cemetaries and forested area, and this could mean generally more negative tweets.

We can also see that areas like Bukit Timah Nature Reserve, Marina Bay, Sentosa and Sungei Boloh Wetland Reserve are the happiest. This is because they are prime recreational areas for both tourists and locals.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
class_int <- classIntervals(hex.sent$i.norm, n = 5, style = "jenks")
rounded <- round(class_int$brks,3)

p <- ggplot() +
  geom_sf(data = hex.sent, aes(fill=cut(i.norm, class_int$brks, include.lowest = TRUE), geometry=geometry, text=paste0("Sentiment: ", i.norm)), lwd=0) + 
  theme_void() +
  coord_sf() +
  scale_fill_viridis(
    name="Normalized Sentiment",
    discrete=T,
    labels = rounded,
    guide=guide_legend(
      keyheight = unit(2, units = "mm"),
      keywidth=unit(12, units = "mm"),
      label.position = "bottom",
      title.position = 'top',
      nrow=1)) +
  labs(
    title = "Instagram Sentiment in Singapore",
    subtitle = "Normalized Sentiment score = (Positive - Negative)/Total Count",
    caption = "Data: Ate Poorthuis | Creation: Dragon Minions"
  ) +
  theme(
    text = element_text(color = "#22211d"), 
    plot.background = element_rect(fill = "#ffffff", color = NA), 
    panel.background = element_rect(fill = "#ffffff", color = NA), 
    legend.background = element_rect(fill = "#ffffff", color = NA),
    plot.title = element_text(size= 18, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.4, l = 2, unit = "cm")),
    legend.position = c(0.79, 0.09),
    panel.grid.major = element_line(colour = 'transparent'), 
    panel.grid.minor = element_line(colour = 'transparent')
  )

p
```

From this map, we can see that Tuas, Lim Chu Kang Road, Tekong, Jurong Island, Woodlands, Yishun, Pulau Ubin and Changi Airport are the least happy. This map supports the inferences from the tweets data in areas like Tuas, Jurong Island, Lim Chu Kang Road and Tekong. given that these are data from two different social media platforms, the inferences seem to be justified. There are also some similarities in the rest of the areas that are least happy wen compared to the tweets data (other than Changi Airport).

When we compare Instagram to Twitter, we can see that posts on Instagram are generally happier. This can be due to the nature of Instagram where more photos are being shared instead of just posting a mood. This can mean that people tend to post less unhappy posts on Instagram as they may not want to blatantly show their negative moods. Twitter on the other hand mainly uses text posts where it appears less expressive. People can just post a simple caption or statement to express their mood in a more subtle manner.

```{r, echo=FALSE, warning=FALSE, message=FALSE}
hex.sent.odds <- hex.sent
hex.sent.odds[hex.sent.odds$odds == 0,]$odds <- NA
hex.sent.odds[hex.sent.odds$i.count < 10,]$odds <- NA
hex.sent.odds[hex.sent.odds$t.count < 10,]$odds <- NA
hex.sent.na <- hex.sent.odds %>% filter(is.na(odds))

class_int <- classIntervals(hex.sent.odds$odds, n = 7, style = "quantile")
rounded <- round(class_int$brks,2)

breaks <- c(0,0.3,0.8,1.1,1.5,222)
colors <- c("#03392B", "#37988D", "#86D0C3", "#edfdff", "#A3C2F8", "#76A7E9", "#0B5FC2")

p <- ggplot() +
  geom_sf(data = hex.sent.odds, aes(fill=cut(odds, breaks = class_int$brks, include.lowest = T), geometry=geometry, text=paste0("Odds Ratio: ", odds)), lwd=0) + 
  theme_void() +
  coord_sf() +
  scale_fill_manual(
    values = colors,
    name="Odds Ratio",
    labels = rounded,
    guide=guide_legend(
      keyheight = unit(2, units = "mm"),
      keywidth=unit(12, units = "mm"),
      label.position = "bottom",
      title.position = 'top',
      nrow=1)) +
  labs(
    title = "Sentiment Odds Ratio in Singapore",
    subtitle = "Odds ratio = (Twitter Sentiment) / (Instagram Sentiment)",
    caption = "Data: Ate Poorthuis | Creation: Dragon Minions"
  ) +
  theme(
    text = element_text(color = "#22211d"), 
    plot.background = element_rect(fill = "#ffffff", color = NA), 
    panel.background = element_rect(fill = "#ffffff", color = NA), 
    legend.background = element_rect(fill = "#ffffff", color = NA),
    plot.title = element_text(size= 22, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.4, l = 2, unit = "cm")),
    legend.position = c(0.745, 0.06),
    panel.grid.major = element_line(colour = 'transparent'), 
    panel.grid.minor = element_line(colour = 'transparent')
  ) + 
  geom_sf(data = hex.sent.na, lwd = 0)

p
# ggplotly(p, tooltip = "text") %>%
#  highlight(
#    "plotly_hover",
#    opacityDim = 1
#  )
```

From this map, we can see that posts in Twitter are generally less happy than Instagram. There are more Red and orange than green and blue. This means that the happiness score on twitter is generally lower than facebook, resulting in low odds ratio.

**II. Sentiments on Weekdays vs Weekends**

```{r, echo = FALSE, message = FALSE, warning = FALSE, error = FALSE}
set.seed(1)

# Retrieved with thanks from http://strimas.com/spatial/hexagonal-grids/
make_grid <- function(x, cell_diameter, cell_area, clip = FALSE) {
  if (missing(cell_diameter)) {
    if (missing(cell_area)) {
      stop("Must provide cell_diameter or cell_area")
    } else {
      cell_diameter <- sqrt(2 * cell_area / sqrt(3))
    }
  }
  ext <- as(extent(x) + cell_diameter, "SpatialPolygons")
  projection(ext) <- projection(x)
  # generate array of hexagon centers
  g <- spsample(ext, type = "hexagonal", cellsize = cell_diameter, 
                offset = c(0.5, 0.5))
  # convert center points to hexagons
  g <- HexPoints2SpatialPolygons(g, dx = cell_diameter)
  # clip to boundary of study area,.
  if (clip) {
    g <- gIntersection(g, x, byid = TRUE)
  } else {
    g <- g[x, ]
  }
  # clean up feature IDs
  row.names(g) <- as.character(1:length(g))
  return(g)
}
    
# read in files
tweets <- invisible(read_csv("emoji_trunc.csv"))
tweets <- tweets %>%
  mutate(date = as_datetime(created_at/1000, tz = "Asia/Singapore")) %>%
  mutate(weekday = wday(date))
insta <- invisible(read_csv("instagram_trunc.csv"))
insta <- insta %>%
  mutate(weekday = wday(created_at))
shape <- invisible(readOGR(dsn = 'sg-shape', layer ='sg-all'))
shape <- gBuffer(shape, byid=TRUE, width=0) # clean up polygons
```

```{r, message = FALSE, warning = FALSE, error = FALSE}
t_wday <- tweets %>%
  filter(weekday < 6) # filter only tweets made on weekdays
  
t_wend <- tweets %>%
  filter(weekday > 5) # filter only tweets made on weekends  
  
i_wday <- insta %>%
  filter(weekday < 6) # filter only igs made on weekdays
  
i_wend <- insta %>%
  filter(weekday > 5) # filter only igs made on weekends  
```
  
```{r, echo = FALSE, message = FALSE, warning = FALSE, error = FALSE}
# convert to sp points and polygon
tweets <- drop_na(t_wday)
# p <- SpatialPointsDataFrame(tweets, data.frame(id=1:728138))
tweets.sf <- st_as_sf(tweets, coords = c('lon','lat'), crs=4326)

insta <- drop_na(i_wday)
insta.sf <- st_as_sf(insta, coords=c('lon', 'lat'), crs=4326)

# pa.kml <- st_read("planning_area.kml")
# pa.sf <- st_as_sf(pa.kml, crs=4326)
# pa.utm <- as(st_zm(pa.sf), "Spatial")
# pa.utm <- gBuffer(pa.utm, byid=TRUE, width=0) # clean up polygons
# shape_utm <- spTransform(shape, CRS(proj4string(shape)))
hex_grid <- make_grid(shape_utm, cell_area = 0.0001, clip = T)
hex.sf <- st_as_sf(hex_grid, crs=4326)
hex.sf <- tibble::rowid_to_column(hex.sf, "hexID")

# points in polygon
colnames(tweets.sf) <- c("t.neg", "t.neu", "t.pos", "t.created_at", "t.sent", "datetime", "wday", "geometry")
colnames(insta.sf) <- c("i.created_at", "i.pos", "i.neu", "i.neg", "i.sent", "datetime", "wday", "geometry")

t.join <- st_join(tweets.sf, hex.sf, join = st_within)
t.join.df <- as.data.frame(t.join)
t.join.summary <- t.join.df %>% group_by(hexID) %>% summarise(t.count = n(), t.pos = sum(t.pos), t.neg = sum(t.neg), t.neu = sum(t.neu)) 
i.join <- st_join(insta.sf, hex.sf, join = st_within)
i.join.df <- as.data.frame(i.join)
i.join.summary <- i.join.df %>% group_by(hexID) %>% summarise(i.count = n(), i.pos = sum(i.pos), i.neg = sum(i.neg), i.neu = sum(i.neu)) 

# Add default values for missing hexagons
for (i in hex.sf$hexID) {
  if (!(i %in% i.join.summary$hexID)) {
    i.join.summary <- rbind(i.join.summary, data.frame(i.count=1, i.pos=0, i.neg=0, i.neu=0, hexID=i))
  }
  if (!(i %in% t.join.summary$hexID)) {
    t.join.summary <- rbind(t.join.summary, data.frame(t.count=1, t.pos=0, t.neg=0, t.neu=0, hexID=i))
  }
}

join.summary <- merge(t.join.summary, i.join.summary, by="hexID")
#join.summary <- join.summary %>% select('t.count', 't.pos', 't.neg', 't.neu', 'i.count', 'i.pos', 'i.neg', 'i.neu', 'hexID') %>% drop_na()

kml.data <- merge(join.summary, hex.sf, by = "hexID") %>% st_as_sf()
kml.data <- st_as_sf(kml.data)
kml.data <- kml.data %>% mutate(t.norm = (t.pos-t.neg)/t.count, i.norm = (i.pos-i.neg)/i.count, odds=t.pos/i.pos)
kml.data[!is.finite(kml.data$odds),]$odds <- 0
# ggplot(kml.data) + geom_histogram(aes(x=odds), bins=30)

# Plot a histogram of the odds
p <- ggplot() +
  geom_sf(data = kml.data, aes(fill=odds, geometry=geometry, text=paste0("Odds Ratio: ", odds)), lwd=0) + 
  theme_void() +
  coord_sf() +
  # scale_fill_viridis(
  #   breaks=c(0,0.25,0.3,0.35,0.4,0.45),
  #   name="Normalized Sentiment",
  #   guide=guide_legend(
  #     keyheight = unit(3, units = "mm"),
  #     keywidth=unit(12, units = "mm"),
  #     label.position = "bottom",
  #     title.position = 'top',
  #     nrow=1)) +
  scale_fill_distiller(
    palette="Spectral",
    limits=c(0,2),
    breaks=c(0,0.3,0.6,1,1.5,2),
    na.value="grey",
    name="Normalized Sentiment",
    guide=guide_legend(
      keyheight = unit(3, units = "mm"),
      keywidth=unit(12, units = "mm"),
      label.position = "bottom",
      title.position = 'top',
      nrow=1)) +
  labs(
    title = "Sentiment Odds Ratio on Weekdays",
    subtitle = "Normalized Sentiment score = (Positive - Negative)/Total Count",
    caption = "Data: Ate Poorthuis | Creation: Dragon Minions"
  ) +
  theme(
    text = element_text(color = "#22211d"), 
    plot.background = element_rect(fill = "#ffffff", color = NA), 
    panel.background = element_rect(fill = "#ffffff", color = NA), 
    legend.background = element_rect(fill = "#ffffff", color = NA),
    plot.title = element_text(size= 18, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.4, l = 2, unit = "cm")),
    legend.position = c(0.82, 0.09),
    panel.grid.major = element_line(colour = 'transparent'), 
    panel.grid.minor = element_line(colour = 'transparent')
  )

#p
ggplotly(p, tooltip = "text") %>%
  highlight(
    "plotly_hover",
    opacityDim = 1
  )
```
  
```{r, echo = FALSE, message = FALSE, warning = FALSE, error = FALSE}
# convert to sp points and polygon
tweets <- drop_na(t_wend)
# p <- SpatialPointsDataFrame(tweets, data.frame(id=1:728138))
tweets.sf <- st_as_sf(tweets, coords = c('lon','lat'), crs=4326)

insta <- drop_na(i_wend)
insta.sf <- st_as_sf(insta, coords=c('lon', 'lat'), crs=4326)

# pa.kml <- st_read("planning_area.kml")
# pa.sf <- st_as_sf(pa.kml, crs=4326)
# pa.utm <- as(st_zm(pa.sf), "Spatial")
# pa.utm <- gBuffer(pa.utm, byid=TRUE, width=0) # clean up polygons
# shape_utm <- spTransform(shape, CRS(proj4string(shape)))
hex_grid <- make_grid(shape_utm, cell_area = 0.0001, clip = T)
hex.sf <- st_as_sf(hex_grid, crs=4326)
hex.sf <- tibble::rowid_to_column(hex.sf, "hexID")

# points in polygon
colnames(tweets.sf) <- c("t.neg", "t.neu", "t.pos", "t.created_at", "t.sent", "datetime", "wday", "geometry")
colnames(insta.sf) <- c("i.created_at", "i.pos", "i.neu", "i.neg", "i.sent", "datetime", "wday", "geometry")

t.join <- st_join(tweets.sf, hex.sf, join = st_within)
t.join.df <- as.data.frame(t.join)
t.join.summary <- t.join.df %>% group_by(hexID) %>% summarise(t.count = n(), t.pos = sum(t.pos), t.neg = sum(t.neg), t.neu = sum(t.neu)) 
i.join <- st_join(insta.sf, hex.sf, join = st_within)
i.join.df <- as.data.frame(i.join)
i.join.summary <- i.join.df %>% group_by(hexID) %>% summarise(i.count = n(), i.pos = sum(i.pos), i.neg = sum(i.neg), i.neu = sum(i.neu)) 

# Add default values for missing hexagons
for (i in hex.sf$hexID) {
  if (!(i %in% i.join.summary$hexID)) {
    i.join.summary <- rbind(i.join.summary, data.frame(i.count=1, i.pos=0, i.neg=0, i.neu=0, hexID=i))
  }
  if (!(i %in% t.join.summary$hexID)) {
    t.join.summary <- rbind(t.join.summary, data.frame(t.count=1, t.pos=0, t.neg=0, t.neu=0, hexID=i))
  }
}

join.summary <- merge(t.join.summary, i.join.summary, by="hexID")
#join.summary <- join.summary %>% select('t.count', 't.pos', 't.neg', 't.neu', 'i.count', 'i.pos', 'i.neg', 'i.neu', 'hexID') %>% drop_na()

kml.data <- merge(join.summary, hex.sf, by = "hexID") %>% st_as_sf()
kml.data <- st_as_sf(kml.data)
kml.data <- kml.data %>% mutate(t.norm = (t.pos-t.neg)/t.count, i.norm = (i.pos-i.neg)/i.count, odds=t.pos/i.pos)
kml.data[!is.finite(kml.data$odds),]$odds <- 0
# ggplot(kml.data) + geom_histogram(aes(x=odds), bins=30)

# Plot a histogram of the odds
p <- ggplot() +
  geom_sf(data = kml.data, aes(fill=odds, geometry=geometry, text=paste0("Odds Ratio: ", odds)), lwd=0) + 
  theme_void() +
  coord_sf() +
  # scale_fill_viridis(
  #   breaks=c(0,0.25,0.3,0.35,0.4,0.45),
  #   name="Normalized Sentiment",
  #   guide=guide_legend(
  #     keyheight = unit(3, units = "mm"),
  #     keywidth=unit(12, units = "mm"),
  #     label.position = "bottom",
  #     title.position = 'top',
  #     nrow=1)) +
  scale_fill_distiller(
    palette="Spectral",
    limits=c(0,2),
    breaks=c(0,0.3,0.6,1,1.5,2),
    na.value="grey",
    name="Normalized Sentiment",
    guide=guide_legend(
      keyheight = unit(3, units = "mm"),
      keywidth=unit(12, units = "mm"),
      label.position = "bottom",
      title.position = 'top',
      nrow=1)) +
  labs(
    title = "Sentiment Odds Ratio on Weekends",
    subtitle = "Normalized Sentiment score = (Positive - Negative)/Total Count",
    caption = "Data: Ate Poorthuis | Creation: Dragon Minions"
  ) +
  theme(
    text = element_text(color = "#22211d"), 
    plot.background = element_rect(fill = "#f5f5f2", color = NA), 
    panel.background = element_rect(fill = "#f5f5f2", color = NA), 
    legend.background = element_rect(fill = "#f5f5f2", color = NA),
    plot.title = element_text(size= 22, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.4, l = 2, unit = "cm")),
    plot.subtitle = element_text(size= 17, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.43, l = 2, unit = "cm")),
    plot.caption = element_text( size=12, color = "#4e4d47", margin = margin(b = 0.3, r=-99, unit = "cm") ),
    legend.position = c(0.7, 0.09),
    panel.grid.major = element_line(colour = 'transparent'), 
    panel.grid.minor = element_line(colour = 'transparent')
  )

#p
ggplotly(p, tooltip = "text") %>%
  highlight(
    "plotly_hover",
    opacityDim = 1
  )
```

We can observe that Singaporeans are marginally happier on weekends compared to weekdays. Generally, social media sentiments are more negative in industrial areas compared to residential areas, and do not change much regardless of the day. We can also notice a change from sad to happy in recreational areas such as East Coast Park and Orchard Road.
  
  
  
**III: Sentiments across various Time Periods** 

We will be dividing the data into 4 time periods: 

* SGT 00:00 - 05:59 
* SGT 06:00 - 11:59  
* SGT 12:00 - 17:59 
* SGT 18:00 - 23:59

```{r, message = FALSE, warning = FALSE, error = FALSE}
# Twitter
  
t_time1 <- tweets %>%
  filter(hour(date) < 6) # filter tweets made between 12am - 6am
  
t_time2 <- tweets %>%
  filter(hour(date) >= 6) %>%
  filter(hour(date) < 12) # filter tweets made between 6am - 12pm
  
t_time3 <- tweets %>%
  filter(hour(date) >= 12) %>%
  filter(hour(date) < 18) # filter tweets made between 12pm - 6pm
  
t_time4 <- tweets %>%
  filter(hour(date) >= 18) # filter tweets made between 6pm - 12am
  
# Instagram
  
i_time1 <- insta %>%
  filter(hour(date) < 6) # filter igs made between 12am - 6am
  
i_time2 <- insta %>%
  filter(hour(date) >= 6) %>%
  filter(hour(date) < 12) # filter igs made between 6am - 12pm
  
i_time3 <- insta %>%
  filter(hour(date) >= 12) %>%
  filter(hour(date) < 18) # filter igs made between 12pm - 6pm
  
i_time4 <- insta %>%
  filter(hour(date) >= 18) # filter igs made between 6pm - 12am
```
  
```{r, echo = FALSE, message = FALSE, warning = FALSE, error = FALSE}
# convert to sp points and polygon
tweets <- drop_na(t_time1)
# p <- SpatialPointsDataFrame(tweets, data.frame(id=1:728138))
tweets.sf <- st_as_sf(tweets, coords = c('lon','lat'), crs=4326)

insta <- drop_na(i_time1)
insta.sf <- st_as_sf(insta, coords=c('lon', 'lat'), crs=4326)

# pa.kml <- st_read("planning_area.kml")
# pa.sf <- st_as_sf(pa.kml, crs=4326)
# pa.utm <- as(st_zm(pa.sf), "Spatial")
# pa.utm <- gBuffer(pa.utm, byid=TRUE, width=0) # clean up polygons
# shape_utm <- spTransform(shape, CRS(proj4string(shape)))
hex_grid <- make_grid(shape_utm, cell_area = 0.0001, clip = T)
hex.sf <- st_as_sf(hex_grid, crs=4326)
hex.sf <- tibble::rowid_to_column(hex.sf, "hexID")

# points in polygon
colnames(tweets.sf) <- c("t.neg", "t.neu", "t.pos", "t.created_at", "t.sent", "datetime", "wday", "geometry")
colnames(insta.sf) <- c("i.created_at", "i.pos", "i.neu", "i.neg", "i.sent", "datetime", "wday", "geometry")

t.join <- st_join(tweets.sf, hex.sf, join = st_within)
t.join.df <- as.data.frame(t.join)
t.join.summary <- t.join.df %>% group_by(hexID) %>% summarise(t.count = n(), t.pos = sum(t.pos), t.neg = sum(t.neg), t.neu = sum(t.neu)) 
i.join <- st_join(insta.sf, hex.sf, join = st_within)
i.join.df <- as.data.frame(i.join)
i.join.summary <- i.join.df %>% group_by(hexID) %>% summarise(i.count = n(), i.pos = sum(i.pos), i.neg = sum(i.neg), i.neu = sum(i.neu)) 

# Add default values for missing hexagons
for (i in hex.sf$hexID) {
  if (!(i %in% i.join.summary$hexID)) {
    i.join.summary <- rbind(i.join.summary, data.frame(i.count=1, i.pos=0, i.neg=0, i.neu=0, hexID=i))
  }
  if (!(i %in% t.join.summary$hexID)) {
    t.join.summary <- rbind(t.join.summary, data.frame(t.count=1, t.pos=0, t.neg=0, t.neu=0, hexID=i))
  }
}

join.summary <- merge(t.join.summary, i.join.summary, by="hexID")
#join.summary <- join.summary %>% select('t.count', 't.pos', 't.neg', 't.neu', 'i.count', 'i.pos', 'i.neg', 'i.neu', 'hexID') %>% drop_na()

kml.data <- merge(join.summary, hex.sf, by = "hexID") %>% st_as_sf()
kml.data <- st_as_sf(kml.data)
kml.data <- kml.data %>% mutate(t.norm = (t.pos-t.neg)/t.count, i.norm = (i.pos-i.neg)/i.count, odds=t.pos/i.pos)
kml.data[!is.finite(kml.data$odds),]$odds <- 0
# ggplot(kml.data) + geom_histogram(aes(x=odds), bins=30)

# Plot a histogram of the odds
p <- ggplot() +
  geom_sf(data = kml.data, aes(fill=odds, geometry=geometry, text=paste0("Odds Ratio: ", odds)), lwd=0) + 
  theme_void() +
  coord_sf() +
  # scale_fill_viridis(
  #   breaks=c(0,0.25,0.3,0.35,0.4,0.45),
  #   name="Normalized Sentiment",
  #   guide=guide_legend(
  #     keyheight = unit(3, units = "mm"),
  #     keywidth=unit(12, units = "mm"),
  #     label.position = "bottom",
  #     title.position = 'top',
  #     nrow=1)) +
  scale_fill_distiller(
    palette="Spectral",
    limits=c(0,2),
    breaks=c(0,0.3,0.6,1,1.5,2),
    na.value="grey",
    name="Normalized Sentiment",
    guide=guide_legend(
      keyheight = unit(3, units = "mm"),
      keywidth=unit(12, units = "mm"),
      label.position = "bottom",
      title.position = 'top',
      nrow=1)) +
  labs(
    title = "Sentiment Odds Ratio from 00:00 - 05:59",
    subtitle = "Normalized Sentiment score = (Positive - Negative)/Total Count",
    caption = "Data: Ate Poorthuis | Creation: Dragon Minions"
  ) +
  theme(
    text = element_text(color = "#22211d"), 
    plot.background = element_rect(fill = "#f5f5f2", color = NA), 
    panel.background = element_rect(fill = "#f5f5f2", color = NA), 
    legend.background = element_rect(fill = "#f5f5f2", color = NA),
    plot.title = element_text(size= 22, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.4, l = 2, unit = "cm")),
    plot.subtitle = element_text(size= 17, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.43, l = 2, unit = "cm")),
    plot.caption = element_text( size=12, color = "#4e4d47", margin = margin(b = 0.3, r=-99, unit = "cm") ),
    legend.position = c(0.7, 0.09),
    panel.grid.major = element_line(colour = 'transparent'), 
    panel.grid.minor = element_line(colour = 'transparent')
  )

#p
ggplotly(p, tooltip = "text") %>%
  highlight(
    "plotly_hover",
    opacityDim = 1
  )
```
  
```{r, echo = FALSE, message = FALSE, warning = FALSE, error = FALSE}
# convert to sp points and polygon
tweets <- drop_na(t_time2)
# p <- SpatialPointsDataFrame(tweets, data.frame(id=1:728138))
tweets.sf <- st_as_sf(tweets, coords = c('lon','lat'), crs=4326)

insta <- drop_na(i_time2)
insta.sf <- st_as_sf(insta, coords=c('lon', 'lat'), crs=4326)

# pa.kml <- st_read("planning_area.kml")
# pa.sf <- st_as_sf(pa.kml, crs=4326)
# pa.utm <- as(st_zm(pa.sf), "Spatial")
# pa.utm <- gBuffer(pa.utm, byid=TRUE, width=0) # clean up polygons
# shape_utm <- spTransform(shape, CRS(proj4string(shape)))
hex_grid <- make_grid(shape_utm, cell_area = 0.0001, clip = T)
hex.sf <- st_as_sf(hex_grid, crs=4326)
hex.sf <- tibble::rowid_to_column(hex.sf, "hexID")

# points in polygon
colnames(tweets.sf) <- c("t.neg", "t.neu", "t.pos", "t.created_at", "t.sent", "datetime", "wday", "geometry")
colnames(insta.sf) <- c("i.created_at", "i.pos", "i.neu", "i.neg", "i.sent", "datetime", "wday", "geometry")

t.join <- st_join(tweets.sf, hex.sf, join = st_within)
t.join.df <- as.data.frame(t.join)
t.join.summary <- t.join.df %>% group_by(hexID) %>% summarise(t.count = n(), t.pos = sum(t.pos), t.neg = sum(t.neg), t.neu = sum(t.neu)) 
i.join <- st_join(insta.sf, hex.sf, join = st_within)
i.join.df <- as.data.frame(i.join)
i.join.summary <- i.join.df %>% group_by(hexID) %>% summarise(i.count = n(), i.pos = sum(i.pos), i.neg = sum(i.neg), i.neu = sum(i.neu)) 

# Add default values for missing hexagons
for (i in hex.sf$hexID) {
  if (!(i %in% i.join.summary$hexID)) {
    i.join.summary <- rbind(i.join.summary, data.frame(i.count=1, i.pos=0, i.neg=0, i.neu=0, hexID=i))
  }
  if (!(i %in% t.join.summary$hexID)) {
    t.join.summary <- rbind(t.join.summary, data.frame(t.count=1, t.pos=0, t.neg=0, t.neu=0, hexID=i))
  }
}

join.summary <- merge(t.join.summary, i.join.summary, by="hexID")
#join.summary <- join.summary %>% select('t.count', 't.pos', 't.neg', 't.neu', 'i.count', 'i.pos', 'i.neg', 'i.neu', 'hexID') %>% drop_na()

kml.data <- merge(join.summary, hex.sf, by = "hexID") %>% st_as_sf()
kml.data <- st_as_sf(kml.data)
kml.data <- kml.data %>% mutate(t.norm = (t.pos-t.neg)/t.count, i.norm = (i.pos-i.neg)/i.count, odds=t.pos/i.pos)
kml.data[!is.finite(kml.data$odds),]$odds <- 0
# ggplot(kml.data) + geom_histogram(aes(x=odds), bins=30)

# Plot a histogram of the odds
p <- ggplot() +
  geom_sf(data = kml.data, aes(fill=odds, geometry=geometry, text=paste0("Odds Ratio: ", odds)), lwd=0) + 
  theme_void() +
  coord_sf() +
  # scale_fill_viridis(
  #   breaks=c(0,0.25,0.3,0.35,0.4,0.45),
  #   name="Normalized Sentiment",
  #   guide=guide_legend(
  #     keyheight = unit(3, units = "mm"),
  #     keywidth=unit(12, units = "mm"),
  #     label.position = "bottom",
  #     title.position = 'top',
  #     nrow=1)) +
  scale_fill_distiller(
    palette="Spectral",
    limits=c(0,2),
    breaks=c(0,0.3,0.6,1,1.5,2),
    na.value="grey",
    name="Normalized Sentiment",
    guide=guide_legend(
      keyheight = unit(3, units = "mm"),
      keywidth=unit(12, units = "mm"),
      label.position = "bottom",
      title.position = 'top',
      nrow=1)) +
  labs(
    title = "Sentiment Odds Ratio from 06:00 - 11:59",
    subtitle = "Normalized Sentiment score = (Positive - Negative)/Total Count",
    caption = "Data: Ate Poorthuis | Creation: Dragon Minions"
  ) +
  theme(
    text = element_text(color = "#22211d"), 
    plot.background = element_rect(fill = "#f5f5f2", color = NA), 
    panel.background = element_rect(fill = "#f5f5f2", color = NA), 
    legend.background = element_rect(fill = "#f5f5f2", color = NA),
    plot.title = element_text(size= 22, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.4, l = 2, unit = "cm")),
    plot.subtitle = element_text(size= 17, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.43, l = 2, unit = "cm")),
    plot.caption = element_text( size=12, color = "#4e4d47", margin = margin(b = 0.3, r=-99, unit = "cm") ),
    legend.position = c(0.7, 0.09),
    panel.grid.major = element_line(colour = 'transparent'), 
    panel.grid.minor = element_line(colour = 'transparent')
  )

#p
ggplotly(p, tooltip = "text") %>%
  highlight(
    "plotly_hover",
    opacityDim = 1
  )
```
  
```{r, echo = FALSE, message = FALSE, warning = FALSE, error = FALSE}
# convert to sp points and polygon
tweets <- drop_na(t_time3)
# p <- SpatialPointsDataFrame(tweets, data.frame(id=1:728138))
tweets.sf <- st_as_sf(tweets, coords = c('lon','lat'), crs=4326)

insta <- drop_na(i_time3)
insta.sf <- st_as_sf(insta, coords=c('lon', 'lat'), crs=4326)

# pa.kml <- st_read("planning_area.kml")
# pa.sf <- st_as_sf(pa.kml, crs=4326)
# pa.utm <- as(st_zm(pa.sf), "Spatial")
# pa.utm <- gBuffer(pa.utm, byid=TRUE, width=0) # clean up polygons
# shape_utm <- spTransform(shape, CRS(proj4string(shape)))
hex_grid <- make_grid(shape_utm, cell_area = 0.0001, clip = T)
hex.sf <- st_as_sf(hex_grid, crs=4326)
hex.sf <- tibble::rowid_to_column(hex.sf, "hexID")

# points in polygon
colnames(tweets.sf) <- c("t.neg", "t.neu", "t.pos", "t.created_at", "t.sent", "datetime", "wday", "geometry")
colnames(insta.sf) <- c("i.created_at", "i.pos", "i.neu", "i.neg", "i.sent", "datetime", "wday", "geometry")

t.join <- st_join(tweets.sf, hex.sf, join = st_within)
t.join.df <- as.data.frame(t.join)
t.join.summary <- t.join.df %>% group_by(hexID) %>% summarise(t.count = n(), t.pos = sum(t.pos), t.neg = sum(t.neg), t.neu = sum(t.neu)) 
i.join <- st_join(insta.sf, hex.sf, join = st_within)
i.join.df <- as.data.frame(i.join)
i.join.summary <- i.join.df %>% group_by(hexID) %>% summarise(i.count = n(), i.pos = sum(i.pos), i.neg = sum(i.neg), i.neu = sum(i.neu)) 

# Add default values for missing hexagons
for (i in hex.sf$hexID) {
  if (!(i %in% i.join.summary$hexID)) {
    i.join.summary <- rbind(i.join.summary, data.frame(i.count=1, i.pos=0, i.neg=0, i.neu=0, hexID=i))
  }
  if (!(i %in% t.join.summary$hexID)) {
    t.join.summary <- rbind(t.join.summary, data.frame(t.count=1, t.pos=0, t.neg=0, t.neu=0, hexID=i))
  }
}

join.summary <- merge(t.join.summary, i.join.summary, by="hexID")
#join.summary <- join.summary %>% select('t.count', 't.pos', 't.neg', 't.neu', 'i.count', 'i.pos', 'i.neg', 'i.neu', 'hexID') %>% drop_na()

kml.data <- merge(join.summary, hex.sf, by = "hexID") %>% st_as_sf()
kml.data <- st_as_sf(kml.data)
kml.data <- kml.data %>% mutate(t.norm = (t.pos-t.neg)/t.count, i.norm = (i.pos-i.neg)/i.count, odds=t.pos/i.pos)
kml.data[!is.finite(kml.data$odds),]$odds <- 0
# ggplot(kml.data) + geom_histogram(aes(x=odds), bins=30)

# Plot a histogram of the odds
p <- ggplot() +
  geom_sf(data = kml.data, aes(fill=odds, geometry=geometry, text=paste0("Odds Ratio: ", odds)), lwd=0) + 
  theme_void() +
  coord_sf() +
  # scale_fill_viridis(
  #   breaks=c(0,0.25,0.3,0.35,0.4,0.45),
  #   name="Normalized Sentiment",
  #   guide=guide_legend(
  #     keyheight = unit(3, units = "mm"),
  #     keywidth=unit(12, units = "mm"),
  #     label.position = "bottom",
  #     title.position = 'top',
  #     nrow=1)) +
  scale_fill_distiller(
    palette="Spectral",
    limits=c(0,2),
    breaks=c(0,0.3,0.6,1,1.5,2),
    na.value="grey",
    name="Normalized Sentiment",
    guide=guide_legend(
      keyheight = unit(3, units = "mm"),
      keywidth=unit(12, units = "mm"),
      label.position = "bottom",
      title.position = 'top',
      nrow=1)) +
  labs(
    title = "Sentiment Odds Ratio from 12:00 - 17:59",
    subtitle = "Normalized Sentiment score = (Positive - Negative)/Total Count",
    caption = "Data: Ate Poorthuis | Creation: Dragon Minions"
  ) +
  theme(
    text = element_text(color = "#22211d"), 
    plot.background = element_rect(fill = "#f5f5f2", color = NA), 
    panel.background = element_rect(fill = "#f5f5f2", color = NA), 
    legend.background = element_rect(fill = "#f5f5f2", color = NA),
    plot.title = element_text(size= 22, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.4, l = 2, unit = "cm")),
    plot.subtitle = element_text(size= 17, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.43, l = 2, unit = "cm")),
    plot.caption = element_text( size=12, color = "#4e4d47", margin = margin(b = 0.3, r=-99, unit = "cm") ),
    legend.position = c(0.7, 0.09),
    panel.grid.major = element_line(colour = 'transparent'), 
    panel.grid.minor = element_line(colour = 'transparent')
  )

#p
ggplotly(p, tooltip = "text") %>%
  highlight(
    "plotly_hover",
    opacityDim = 1
  )
```
  
```{r, echo = FALSE, message = FALSE, warning = FALSE, error = FALSE}
# convert to sp points and polygon
tweets <- drop_na(t_time4)
# p <- SpatialPointsDataFrame(tweets, data.frame(id=1:728138))
tweets.sf <- st_as_sf(tweets, coords = c('lon','lat'), crs=4326)

insta <- drop_na(i_time4)
insta.sf <- st_as_sf(insta, coords=c('lon', 'lat'), crs=4326)

# pa.kml <- st_read("planning_area.kml")
# pa.sf <- st_as_sf(pa.kml, crs=4326)
# pa.utm <- as(st_zm(pa.sf), "Spatial")
# pa.utm <- gBuffer(pa.utm, byid=TRUE, width=0) # clean up polygons
# shape_utm <- spTransform(shape, CRS(proj4string(shape)))
hex_grid <- make_grid(shape_utm, cell_area = 0.0001, clip = T)
hex.sf <- st_as_sf(hex_grid, crs=4326)
hex.sf <- tibble::rowid_to_column(hex.sf, "hexID")

# points in polygon
colnames(tweets.sf) <- c("t.neg", "t.neu", "t.pos", "t.created_at", "t.sent", "datetime", "wday", "geometry")
colnames(insta.sf) <- c("i.created_at", "i.pos", "i.neu", "i.neg", "i.sent", "datetime", "wday", "geometry")

t.join <- st_join(tweets.sf, hex.sf, join = st_within)
t.join.df <- as.data.frame(t.join)
t.join.summary <- t.join.df %>% group_by(hexID) %>% summarise(t.count = n(), t.pos = sum(t.pos), t.neg = sum(t.neg), t.neu = sum(t.neu)) 
i.join <- st_join(insta.sf, hex.sf, join = st_within)
i.join.df <- as.data.frame(i.join)
i.join.summary <- i.join.df %>% group_by(hexID) %>% summarise(i.count = n(), i.pos = sum(i.pos), i.neg = sum(i.neg), i.neu = sum(i.neu)) 

# Add default values for missing hexagons
for (i in hex.sf$hexID) {
  if (!(i %in% i.join.summary$hexID)) {
    i.join.summary <- rbind(i.join.summary, data.frame(i.count=1, i.pos=0, i.neg=0, i.neu=0, hexID=i))
  }
  if (!(i %in% t.join.summary$hexID)) {
    t.join.summary <- rbind(t.join.summary, data.frame(t.count=1, t.pos=0, t.neg=0, t.neu=0, hexID=i))
  }
}

join.summary <- merge(t.join.summary, i.join.summary, by="hexID")
#join.summary <- join.summary %>% select('t.count', 't.pos', 't.neg', 't.neu', 'i.count', 'i.pos', 'i.neg', 'i.neu', 'hexID') %>% drop_na()

kml.data <- merge(join.summary, hex.sf, by = "hexID") %>% st_as_sf()
kml.data <- st_as_sf(kml.data)
kml.data <- kml.data %>% mutate(t.norm = (t.pos-t.neg)/t.count, i.norm = (i.pos-i.neg)/i.count, odds=t.pos/i.pos)
kml.data[!is.finite(kml.data$odds),]$odds <- 0
# ggplot(kml.data) + geom_histogram(aes(x=odds), bins=30)

# Plot a histogram of the odds
p <- ggplot() +
  geom_sf(data = kml.data, aes(fill=odds, geometry=geometry, text=paste0("Odds Ratio: ", odds)), lwd=0) + 
  theme_void() +
  coord_sf() +
  # scale_fill_viridis(
  #   breaks=c(0,0.25,0.3,0.35,0.4,0.45),
  #   name="Normalized Sentiment",
  #   guide=guide_legend(
  #     keyheight = unit(3, units = "mm"),
  #     keywidth=unit(12, units = "mm"),
  #     label.position = "bottom",
  #     title.position = 'top',
  #     nrow=1)) +
  scale_fill_distiller(
    palette="Spectral",
    limits=c(0,2),
    breaks=c(0,0.3,0.6,1,1.5,2),
    na.value="grey",
    name="Normalized Sentiment",
    guide=guide_legend(
      keyheight = unit(3, units = "mm"),
      keywidth=unit(12, units = "mm"),
      label.position = "bottom",
      title.position = 'top',
      nrow=1)) +
  labs(
    title = "Sentiment Odds Ratio from 18:00 - 23:59",
    subtitle = "Normalized Sentiment score = (Positive - Negative)/Total Count",
    caption = "Data: Ate Poorthuis | Creation: Dragon Minions"
  ) +
  theme(
    text = element_text(color = "#22211d"), 
    plot.background = element_rect(fill = "#f5f5f2", color = NA), 
    panel.background = element_rect(fill = "#f5f5f2", color = NA), 
    legend.background = element_rect(fill = "#f5f5f2", color = NA),
    plot.title = element_text(size= 22, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.4, l = 2, unit = "cm")),
    plot.subtitle = element_text(size= 17, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.43, l = 2, unit = "cm")),
    plot.caption = element_text( size=12, color = "#4e4d47", margin = margin(b = 0.3, r=-99, unit = "cm") ),
    legend.position = c(0.7, 0.09),
    panel.grid.major = element_line(colour = 'transparent'), 
    panel.grid.minor = element_line(colour = 'transparent')
  )

#p
ggplotly(p, tooltip = "text") %>%
  highlight(
    "plotly_hover",
    opacityDim = 1
  )
```
  
**Some general observations that we can make based on time periods:**  

* Singaporeans are happiest on social media from 12:00 - 17:59.  
* From 18:00 - 23:59, residential areas remain largely happy, whereas the industrial areas (South and West parts of Singapore) are least happy (probably due to the need to work overtime).  
* From 00:00 - 05:59, sentiments are largely unhappy, with small "happy" clusters around Choa Chu Kang, Ang Mo Kio, Geylang, Bedok and Tampines areas (possibly areas with 24/7 food options, and other *night activities*).
* The east remains happy regardless of time period, I wonder why. 





**IV: Sentiments among Different Housing Types**

```{r, echo=FALSE, warning=FALSE, message=FALSE}

rounded <- polygons.sf$norm %>% 
  unique() 
rounded <- rounded[order(rounded)]
rounded <- round(rounded, 3)

tampines <- get_map("Singapore-Tampines", zoom = 14, maptype = "toner-lines")

p <- ggmap(tampines) +
  geom_sf(data = polygons.sf,
          aes(fill = factor(norm), text = paste0(Name, "\n", "Sentiment: ", round(norm,2))),
          lwd = 0, 
          alpha = 0.8,
          inherit.aes = FALSE) + 
  theme_void() +
  coord_sf() +
  scale_fill_viridis(
    discrete = T,
    name="Normalized Sentiment",
    labels = rounded,
    guide=guide_legend(
      keyheight = unit(4, units = "mm"),
      keywidth=unit(8, units = "mm"),
      label.position = "right",
      title.position = 'top',
      alpha = 1)) +
  labs(
    title = "Sentiments of Singaporeans Living Near Tampines",
    subtitle = "Normalized Sentiment score = (Positive - Negative)/Total Count",
    caption = "Data: Ate Poorthuis | Creation: Dragon Minions"
  ) +
  theme(
    text = element_text(color = "#22211d"),
    plot.background = element_rect(fill = "#ffffff", color = NA),
    panel.background = element_rect(fill = "#ffffff", color = NA),
    legend.background = element_rect(fill = "#ffffff", color = NA),
    plot.title = element_text(size= 16, hjust=0.01, color = "#4e4d47", margin = margin(b = -0.1, t = 0.4, l = 2, unit = "cm")),
    panel.grid.major = element_line(colour = 'transparent'),
    panel.grid.minor = element_line(colour = 'transparent')
  ) 

#p

l <- list(
  font = list(
    family = "sans-serif",
    size = 12,
    color = "#000"),
  x = 0.7,
  y = 0,
  bgcolor = "transparent",
  bordercolor = "#FFFFFF",
  orientation = 'h',
  borderwidth = 0)

ggplotly(p, tooltip = "text") %>%
 highlight(
   "plotly_hover",
   opacityDim = 1
 ) %>%
  layout(legend = l)
```

From this map, we can see that people living in landed properties are generally the happiest, followed by condo owners, and finally HDB flat owners. This could be a good indication of the correlation between wealth and happiness. People living in private estates represent wealthier families and are actually happier than less well-off Singaporeans. However, the sample size is relatively small. While the data is interesting and supports the intuitive correlation between wealth and happiness, more investigation is needed. This is a good starting point in opening up a thesis for social research on wealth and happiness nonetheless.
